<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Doge Whale Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background: linear-gradient(to bottom, #4169E1, #000080);
            color: white;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        header {
            background-color: rgba(0, 0, 128, 0.7);
            padding: 10px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .user-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .coin-display {
            display: flex;
            align-items: center;
            gap: 5px;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 20px;
        }
        
        .coin-icon {
            width: 20px;
            height: 20px;
            background-color: gold;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #333;
        }
        
        .nav-buttons {
            display: flex;
            gap: 10px;
        }
        
        .nav-button {
            background-color: rgba(65, 105, 225, 0.7);
            border: 2px solid #87CEEB;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .nav-button:hover {
            background-color: rgba(135, 206, 235, 0.7);
            transform: scale(1.05);
        }
        
        main {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 500px;
            background-color: rgba(30, 144, 255, 0.3);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
            overflow: hidden;
        }
        
        #game-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 128, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }
        
        .overlay.active {
            opacity: 1;
            pointer-events: all;
        }
        
        .overlay h2 {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        
        .overlay p {
            font-size: 18px;
            margin-bottom: 30px;
            max-width: 80%;
            text-align: center;
        }
        
        .button {
            background-color: #4169E1;
            color: white;
            border: none;
            padding: 10px 30px;
            font-size: 18px;
            border-radius: 30px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
        }
        
        .button:hover {
            background-color: #87CEEB;
            transform: scale(1.05);
        }
        
        #hud {
            position: absolute;
            top: 10px;
            left: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        
        .bar-container {
            width: 200px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            overflow: hidden;
        }
        
        #health-bar {
            height: 100%;
            width: 100%;
            background: linear-gradient(to right, #FF4500, #FF8C00);
            transition: width 0.3s;
        }
        
        #power-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(to right, #4169E1, #00BFFF);
            transition: width 0.3s;
        }
        
        #score-display {
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 36px;
            font-weight: bold;
            color: white;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
        }
        
        #combo-display {
            position: absolute;
            top: 50px;
            right: 10px;
            font-size: 24px;
            color: gold;
            text-shadow: 0 0 5px rgba(0, 0, 0, 0.5);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        #power-up-notification {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 18px;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
        }
        
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            display: flex;
            gap: 20px;
        }
        
        .mobile-button {
            width: 50px;
            height: 50px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
        }
        
        #combat-controls {
            position: absolute;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 20px;
        }
        
        .combat-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
        }
        
        #combat-fire {
            background-color: rgba(255, 69, 0, 0.7);
        }
        
        #combat-special {
            background-color: rgba(65, 105, 225, 0.7);
        }
        
        #orientation-toggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }
        
        .vertical #game-container {
            width: 400px;
            height: 600px;
        }
        
        .background-particle {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            animation: float var(--duration) linear infinite;
        }
        
        @keyframes float {
            0% {
                transform: translateY(100vh);
            }
            100% {
                transform: translateY(-100px);
            }
        }
        
        .cloud {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            pointer-events: none;
            animation: drift 30s linear infinite;
        }
        
        @keyframes drift {
            0% {
                transform: translateX(-100px);
            }
            100% {
                transform: translateX(100vw);
            }
        }
        
        .water-wave {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 50px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="%230099ff" fill-opacity="0.5" d="M0,192L48,197.3C96,203,192,213,288,229.3C384,245,480,267,576,250.7C672,235,768,181,864,181.3C960,181,1056,235,1152,234.7C1248,235,1344,181,1392,154.7L1440,128L1440,320L1392,320C1344,320,1248,320,1152,320C1056,320,960,320,864,320C768,320,672,320,576,320C480,320,384,320,288,320C192,320,96,320,48,320L0,320Z"></path></svg>');
            background-size: cover;
            animation: wave 10s linear infinite;
        }
        
        @keyframes wave {
            0% {
                background-position-x: 0;
            }
            100% {
                background-position-x: 1000px;
            }
        }
        
        #cloud-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100px;
            overflow: hidden;
            pointer-events: none;
        }
        
        @media (max-width: 768px) {
            #game-container {
                width: 100%;
                height: 100%;
                border-radius: 0;
            }
            
            header {
                padding: 5px 10px;
            }
            
            h1 {
                font-size: 18px;
            }
            
            .nav-button {
                padding: 3px 10px;
                font-size: 14px;
            }
            
            #hud {
                top: 5px;
                left: 5px;
            }
            
            .bar-container {
                width: 150px;
                height: 15px;
            }
            
            #score-display {
                font-size: 24px;
            }
            
            #combo-display {
                font-size: 18px;
            }
            
            .mobile-button, .combat-button {
                width: 40px;
                height: 40px;
                font-size: 18px;
            }
        }
    </style>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
</head>
<body>
    <header>
        <h1>Doge Whale Game</h1>
        <div class="nav-buttons">
            <button class="nav-button" id="play-button">Play</button>
            <button class="nav-button" id="store-button">Store</button>
            <button class="nav-button" id="leaderboard-button">Leaderboard</button>
        </div>
        <div class="user-info">
            <span>Guest</span>
            <div class="coin-display">
                <div class="coin-icon">$</div>
                <span id="coin-count">0</span>
            </div>
        </div>
    </header>
    
    <main>
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
            
            <div id="hud">
                <div class="bar-container">
                    <div id="health-bar"></div>
                </div>
                <div class="bar-container">
                    <div id="power-bar"></div>
                </div>
            </div>
            
            <div id="score-display">0</div>
            <div id="combo-display">Combo x1</div>
            <div id="power-up-notification"></div>
            
            <div id="mobile-controls">
                <div class="mobile-button" id="mobile-up"><i class="fas fa-arrow-up"></i></div>
                <div class="mobile-button" id="mobile-down"><i class="fas fa-arrow-down"></i></div>
            </div>
            
            <div id="combat-controls">
                <div class="combat-button" id="combat-fire"><i class="fas fa-bolt"></i></div>
                <div class="combat-button" id="combat-special"><i class="fas fa-star"></i></div>
            </div>
            
            <div class="overlay active" id="start-overlay">
                <h2>Doge Whale Game</h2>
                <p>Navigate through pipes and defeat enemy whales!</p>
                <button class="button" id="start-button">Start Game</button>
            </div>
            
            <div class="overlay" id="game-over-overlay">
                <h2>Game Over</h2>
                <p>Your score: <span id="final-score">0</span></p>
                <button class="button" id="restart-button">Play Again</button>
            </div>
            
            <div class="water-wave"></div>
            <div id="cloud-container"></div>
        </div>
    </main>
    
    <div id="orientation-toggle">
        <i class="fas fa-mobile-alt"></i>
    </div>
    
    <script>
        // Animation scripts
        // Main whale swimming animation
        const mainWhaleSwimFrames = [
            {
                tailAngle: -15,
                finOffset: -2,
                bubbleCount: 1
            },
            {
                tailAngle: -5,
                finOffset: -1,
                bubbleCount: 0
            },
            {
                tailAngle: 0,
                finOffset: 0,
                bubbleCount: 0
            },
            {
                tailAngle: 5,
                finOffset: 1,
                bubbleCount: 2
            },
            {
                tailAngle: 15,
                finOffset: 2,
                bubbleCount: 1
            },
            {
                tailAngle: 5,
                finOffset: 1,
                bubbleCount: 0
            },
            {
                tailAngle: 0,
                finOffset: 0,
                bubbleCount: 0
            },
            {
                tailAngle: -5,
                finOffset: -1,
                bubbleCount: 1
            }
        ];

        // Animation function for main whale swimming
        function animateMainWhaleSwim(ctx, whale, frameCount) {
            // Save context state
            ctx.save();
            
            // Translate to whale center
            ctx.translate(whale.x + whale.width / 2, whale.y + whale.height / 2);
            
            // Get current animation frame
            const frameIndex = Math.floor(frameCount / 8) % mainWhaleSwimFrames.length;
            const frame = mainWhaleSwimFrames[frameIndex];
            
            // Draw whale body
            ctx.drawImage(
                playerImage, 
                -whale.width / 2, 
                -whale.height / 2, 
                whale.width, 
                whale.height
            );
            
            // Draw tail with animation
            ctx.save();
            ctx.translate(-whale.width / 2, 0);
            ctx.rotate(frame.tailAngle * Math.PI / 180);
            
            // Draw tail (simplified representation)
            ctx.fillStyle = '#FFD700'; // Yellow color matching the whale
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-10, -10);
            ctx.lineTo(-15, 0);
            ctx.lineTo(-10, 10);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // Draw fin with animation
            ctx.fillStyle = '#FFD700';
            ctx.beginPath();
            ctx.moveTo(0, -whale.height / 2);
            ctx.lineTo(5, -whale.height / 2 - 8 + frame.finOffset);
            ctx.lineTo(10, -whale.height / 2);
            ctx.closePath();
            ctx.fill();
            
            // Draw bubbles if needed
            if (frame.bubbleCount > 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                for (let i = 0; i < frame.bubbleCount; i++) {
                    const bubbleX = -whale.width / 2 - 10 - (i * 5);
                    const bubbleY = (Math.random() - 0.5) * 10;
                    const bubbleSize = 2 + Math.random() * 3;
                    
                    ctx.beginPath();
                    ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Restore context state
            ctx.restore();
        }

        // Main whale attack animation
        const mainWhaleAttackFrames = [
            {
                mouthOpen: 0,
                eyeSize: 1,
                glowIntensity: 0
            },
            {
                mouthOpen: 5,
                eyeSize: 1.2,
                glowIntensity: 0.2
            },
            {
                mouthOpen: 10,
                eyeSize: 1.5,
                glowIntensity: 0.5
            },
            {
                mouthOpen: 15,
                eyeSize: 1.8,
                glowIntensity: 0.8
            },
            {
                mouthOpen: 20,
                eyeSize: 2,
                glowIntensity: 1
            },
            {
                mouthOpen: 15,
                eyeSize: 1.8,
                glowIntensity: 0.8
            },
            {
                mouthOpen: 10,
                eyeSize: 1.5,
                glowIntensity: 0.5
            },
            {
                mouthOpen: 5,
                eyeSize: 1.2,
                glowIntensity: 0.2
            }
        ];

        // Animation function for main whale attack
        function animateMainWhaleAttack(ctx, whale, frameCount, isAttacking) {
            // If not attacking, use regular swim animation
            if (!isAttacking) {
                animateMainWhaleSwim(ctx, whale, frameCount);
                return;
            }
            
            // Save context state
            ctx.save();
            
            // Translate to whale center
            ctx.translate(whale.x + whale.width / 2, whale.y + whale.height / 2);
            
            // Get current animation frame
            const frameIndex = Math.floor(frameCount / 4) % mainWhaleAttackFrames.length;
            const frame = mainWhaleAttackFrames[frameIndex];
            
            // Draw attack glow effect
            if (frame.glowIntensity > 0) {
                ctx.save();
                ctx.globalAlpha = frame.glowIntensity * 0.7;
                ctx.shadowBlur = 15 * frame.glowIntensity;
                ctx.shadowColor = '#FFD700';
                ctx.fillStyle = 'rgba(255, 215, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(0, 0, whale.width * 0.7, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw whale body
            ctx.drawImage(
                playerImage, 
                -whale.width / 2, 
                -whale.height / 2, 
                whale.width, 
                whale.height
            );
            
            // Draw mouth with animation (opening wider) - using yellow/orange color instead of red
            ctx.fillStyle = '#FFA500'; // Changed from '#FF4500' (red) to orange
            ctx.beginPath();
            ctx.arc(whale.width / 2 - 5, 0, 5 + frame.mouthOpen, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw eyes with animation (getting larger/brighter) - using yellow color instead of red
            ctx.fillStyle = '#FFD700'; // Changed from '#FF0000' (red) to gold
            ctx.beginPath();
            ctx.arc(whale.width / 4, -whale.height / 4, 3 * frame.eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(whale.width / 4, whale.height / 4, 3 * frame.eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw attack particles
            if (frame.glowIntensity > 0.5) {
                ctx.fillStyle = 'rgba(255, 215, 0, 0.7)';
                for (let i = 0; i < 5; i++) {
                    const particleX = whale.width / 2 + 10 + (i * 3);
                    const particleY = (Math.random() - 0.5) * 20;
                    const particleSize = 2 + Math.random() * 3;
                    
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Restore context state
            ctx.restore();
        }

        // Enemy whale swimming animation
        const enemyWhaleSwimFrames = [
            {
                tailAngle: 15,
                finOffset: 2,
                bubbleCount: 1
            },
            {
                tailAngle: 5,
                finOffset: 1,
                bubbleCount: 0
            },
            {
                tailAngle: 0,
                finOffset: 0,
                bubbleCount: 0
            },
            {
                tailAngle: -5,
                finOffset: -1,
                bubbleCount: 2
            },
            {
                tailAngle: -15,
                finOffset: -2,
                bubbleCount: 1
            },
            {
                tailAngle: -5,
                finOffset: -1,
                bubbleCount: 0
            },
            {
                tailAngle: 0,
                finOffset: 0,
                bubbleCount: 0
            },
            {
                tailAngle: 5,
                finOffset: 1,
                bubbleCount: 1
            }
        ];

        // Animation function for enemy whale swimming
        function animateEnemyWhaleSwim(ctx, enemy, frameCount) {
            // Save context state
            ctx.save();
            
            // Translate to enemy center
            ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            
            // Rotate to face player
            ctx.rotate(Math.PI); // Rotate 180 degrees to face left (towards player)
            
            // Get current animation frame
            const frameIndex = Math.floor((frameCount + enemy.id * 10) / 8) % enemyWhaleSwimFrames.length;
            const frame = enemyWhaleSwimFrames[frameIndex];
            
            // Draw enemy body
            ctx.drawImage(
                enemy.image, 
                -enemy.width / 2, 
                -enemy.height / 2, 
                enemy.width, 
                enemy.height
            );
            
            // Draw tail with animation
            ctx.save();
            ctx.translate(-enemy.width / 2, 0);
            ctx.rotate(frame.tailAngle * Math.PI / 180);
            
            // Draw tail (simplified representation)
            ctx.fillStyle = enemy.color || '#FF5252'; // Red color matching the enemy whale
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(-10, -10);
            ctx.lineTo(-15, 0);
            ctx.lineTo(-10, 10);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
            
            // Draw fin with animation
            ctx.fillStyle = enemy.color || '#FF5252';
            ctx.beginPath();
            ctx.moveTo(0, -enemy.height / 2);
            ctx.lineTo(5, -enemy.height / 2 - 8 + frame.finOffset);
            ctx.lineTo(10, -enemy.height / 2);
            ctx.closePath();
            ctx.fill();
            
            // Draw bubbles if needed
            if (frame.bubbleCount > 0) {
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                for (let i = 0; i < frame.bubbleCount; i++) {
                    const bubbleX = -enemy.width / 2 - 10 - (i * 5);
                    const bubbleY = (Math.random() - 0.5) * 10;
                    const bubbleSize = 2 + Math.random() * 3;
                    
                    ctx.beginPath();
                    ctx.arc(bubbleX, bubbleY, bubbleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Restore context state
            ctx.restore();
        }

        // Enemy whale attack animation
        const enemyWhaleAttackFrames = [
            {
                mouthOpen: 0,
                eyeSize: 1,
                glowIntensity: 0
            },
            {
                mouthOpen: 5,
                eyeSize: 1.2,
                glowIntensity: 0.2
            },
            {
                mouthOpen: 10,
                eyeSize: 1.5,
                glowIntensity: 0.5
            },
            {
                mouthOpen: 15,
                eyeSize: 1.8,
                glowIntensity: 0.8
            },
            {
                mouthOpen: 20,
                eyeSize: 2,
                glowIntensity: 1
            },
            {
                mouthOpen: 15,
                eyeSize: 1.8,
                glowIntensity: 0.8
            },
            {
                mouthOpen: 10,
                eyeSize: 1.5,
                glowIntensity: 0.5
            },
            {
                mouthOpen: 5,
                eyeSize: 1.2,
                glowIntensity: 0.2
            }
        ];

        // Animation function for enemy whale attack
        function animateEnemyWhaleAttack(ctx, enemy, frameCount, isAttacking) {
            // If not attacking, use regular swim animation
            if (!isAttacking) {
                animateEnemyWhaleSwim(ctx, enemy, frameCount);
                return;
            }
            
            // Save context state
            ctx.save();
            
            // Translate to enemy center
            ctx.translate(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
            
            // Rotate to face player
            ctx.rotate(Math.PI); // Rotate 180 degrees to face left (towards player)
            
            // Get current animation frame
            const frameIndex = Math.floor(frameCount / 4) % enemyWhaleAttackFrames.length;
            const frame = enemyWhaleAttackFrames[frameIndex];
            
            // Draw attack glow effect
            if (frame.glowIntensity > 0) {
                ctx.save();
                ctx.globalAlpha = frame.glowIntensity * 0.7;
                ctx.shadowBlur = 15 * frame.glowIntensity;
                ctx.shadowColor = enemy.color || '#FF5252';
                ctx.fillStyle = `rgba(${enemy.color || '255, 82, 82'}, 0.3)`;
                ctx.beginPath();
                ctx.arc(0, 0, enemy.width * 0.7, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
            
            // Draw enemy body
            ctx.drawImage(
                enemy.image, 
                -enemy.width / 2, 
                -enemy.height / 2, 
                enemy.width, 
                enemy.height
            );
            
            // Draw mouth with animation (opening wider)
            ctx.fillStyle = '#FF4500';
            ctx.beginPath();
            ctx.arc(enemy.width / 2 - 5, 0, 5 + frame.mouthOpen, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw eyes with animation (getting larger/brighter)
            ctx.fillStyle = '#FF0000';
            ctx.beginPath();
            ctx.arc(enemy.width / 4, -enemy.height / 4, 3 * frame.eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.beginPath();
            ctx.arc(enemy.width / 4, enemy.height / 4, 3 * frame.eyeSize, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw attack particles
            if (frame.glowIntensity > 0.5) {
                ctx.fillStyle = 'rgba(255, 69, 0, 0.7)';
                for (let i = 0; i < 5; i++) {
                    const particleX = enemy.width / 2 + 10 + (i * 3);
                    const particleY = (Math.random() - 0.5) * 20;
                    const particleSize = 2 + Math.random() * 3;
                    
                    ctx.beginPath();
                    ctx.arc(particleX, particleY, particleSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Restore context state
            ctx.restore();
        }

        // Animation state tracking
        let frameCount = 0;
        let mainWhaleAttacking = false;
        let enemyAttackingStates = {};

        // Function to trigger main whale attack animation
        function triggerMainWhaleAttack() {
            mainWhaleAttacking = true;
        }

        // Function to trigger enemy whale attack animation
        function triggerEnemyWhaleAttack(enemyId) {
            if (!enemyAttackingStates[enemyId]) {
                enemyAttackingStates[enemyId] = { attacking: false, timer: 0 };
            }
            
            enemyAttackingStates[enemyId].attacking = true;
            enemyAttackingStates[enemyId].timer = 32; // Animation duration in frames
        }

        // Game variables
        let gameActive = false;
        let score = 0;
        let health = 100;
        let power = 0;
        let combo = 0;
        let gameSpeed = 2;
        let gravity = 0.5;
        let isVertical = true; // Default to vertical orientation

        // Game objects
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const gameContainer = document.getElementById('game-container');
        const scoreDisplay = document.getElementById('score-display');
        const healthBar = document.getElementById('health-bar');
        const powerBar = document.getElementById('power-bar');
        const comboDisplay = document.getElementById('combo-display');
        const powerUpNotification = document.getElementById('power-up-notification');
        const startOverlay = document.getElementById('start-overlay');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const finalScoreDisplay = document.getElementById('final-score');
        const startButton = document.getElementById('start-button');
        const restartButton = document.getElementById('restart-button');
        const orientationToggle = document.getElementById('orientation-toggle');

        // Character and enemy images
        const playerImage = new Image();
        playerImage.src = 'https://iili.io/3PHNlSf.png'; // Yellow whale character

        const enemyImages = [
            'https://iili.io/3PHNGdN.png', // Red whale
            'https://iili.io/3PHNJmv.png', // Red whale with hat
            'https://iili.io/3PHNVWb.png', // Red whale with hat and weapon
            'https://iili.io/3PHNWlX.png', // Orange whale
            'https://iili.io/3PHNMGa.png', // Orange whale with green weapon
            'https://iili.io/3PHNDpg.png', // Red whale with glasses
            'https://iili.io/3PHN1Vj.png', // Orange whale with green weapon
            'https://iili.io/3PHN3nQ.png', // Blue whale
            'https://iili.io/3PHNFAx.png'  // Orange whale with red weapon
        ];

        // Sea turtle and snake images
        const seaTurtleImage = new Image();
        seaTurtleImage.src = 'https://i.imgur.com/JZjCGpr.png'; // Sea turtle image

        const snakeImage = new Image();
        snakeImage.src = 'https://i.imgur.com/8XR9Ada.png'; // Snake image

        // Load enemy images
        const enemyImageObjects = enemyImages.map(src => {
            const img = new Image();
            img.src = src;
            return img;
        });
        
        // Game objects
        let player = {
            x: canvas.width / 4, // Fixed horizontal position in left side
            y: canvas.height / 2,
            width: 60,
            height: 40,
            velocity: 0,
            isJumping: false,
            autoFire: true,
            fireTimer: 0,
            fireRate: 30 // Fire every 30 frames
        };
        
        let pipes = [];
        let enemies = [];
        let projectiles = [];
        let enemyProjectiles = [];
        let particles = [];
        let powerUps = [];

        // Initialize game
        function initGame() {
            console.log("Game initialized!");
            // Reset game state
            gameActive = true;
            score = 0;
            health = 100;
            power = 0;
            combo = 0;
            gameSpeed = 2;
            
            // Reset game objects
            player = {
                x: canvas.width / 4, // Fixed horizontal position in left side
                y: canvas.height / 2,
                width: 60,
                height: 40,
                velocity: 0,
                isJumping: false,
                autoFire: true,
                fireTimer: 0,
                fireRate: 30 // Fire every 30 frames
            };
            
            pipes = [];
            enemies = [];
            projectiles = [];
            enemyProjectiles = [];
            particles = [];
            powerUps = [];
            
            // Update UI
            scoreDisplay.textContent = score;
            healthBar.style.width = '100%';
            powerBar.style.width = '0%';
            comboDisplay.style.opacity = '0';
            
            // Hide overlays
            startOverlay.classList.remove('active');
            gameOverOverlay.classList.remove('active');
            
            // Start game loop
            requestAnimationFrame(gameLoop);
            
            // Start spawning pipes and enemies
            spawnPipe();
            spawnEnemy();
        }

        // Game loop
        function gameLoop() {
            if (!gameActive) return;
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Update animations
            updateAnimations();
            
            // Update game objects
            updatePlayer();
            updatePipes();
            updateEnemies();
            updateProjectiles();
            updateEnemyProjectiles();
            updateParticles();
            updatePowerUps();
            
            // Draw game objects
            drawBackground();
            drawPipes();
            drawPlayer();
            drawEnemies();
            drawProjectiles();
            drawEnemyProjectiles();
            drawParticles();
            drawPowerUps();
            
            // Check collisions
            checkCollisions();
            
            // Update score
            score += 0.1;
            scoreDisplay.textContent = Math.floor(score);
            
            // Request next frame
            requestAnimationFrame(gameLoop);
        }

        // Update animations
        function updateAnimations() {
            frameCount++;
            
            // Reset main whale attack state if needed
            if (mainWhaleAttacking && frameCount % 32 === 0) {
                mainWhaleAttacking = false;
            }
            
            // Update enemy attack states
            for (const enemyId in enemyAttackingStates) {
                if (enemyAttackingStates[enemyId].attacking) {
                    enemyAttackingStates[enemyId].timer--;
                    if (enemyAttackingStates[enemyId].timer <= 0) {
                        enemyAttackingStates[enemyId].attacking = false;
                    }
                }
            }
        }

        // Update player
        function updatePlayer() {
            // Apply gravity
            player.velocity += gravity;
            player.y += player.velocity;
            
            // Keep player fixed horizontally
            player.x = canvas.width / 4; // Ensure player stays at fixed horizontal position
            
            // Keep player within canvas bounds
            if (player.y < 0) {
                player.y = 0;
                player.velocity = 0;
            }
            
            if (player.y + player.height > canvas.height) {
                player.y = canvas.height - player.height;
                player.velocity = 0;
                player.isJumping = false;
            }
            
            // Auto-fire logic
            if (player.autoFire) {
                player.fireTimer--;
                if (player.fireTimer <= 0) {
                    fireProjectile();
                    player.fireTimer = player.fireRate;
                }
            }
        }

        // Draw player
        function drawPlayer() {
            // Use animation instead of static image
            if (mainWhaleAttacking) {
                animateMainWhaleAttack(ctx, player, frameCount, true);
            } else {
                animateMainWhaleSwim(ctx, player, frameCount);
            }
        }

        // Update pipes
        function updatePipes() {
            for (let i = 0; i < pipes.length; i++) {
                pipes[i].x -= gameSpeed;
                
                // Remove pipes that are off screen
                if (pipes[i].x + pipes[i].width < 0) {
                    pipes.splice(i, 1);
                    i--;
                    
                    // Increase score
                    score += 10;
                    scoreDisplay.textContent = Math.floor(score);
                }
            }
            
            // Spawn new pipes if needed
            if (pipes.length === 0 || pipes[pipes.length - 1].x < canvas.width - 300) {
                spawnPipe();
            }
        }

        // Draw pipes
        function drawPipes() {
            for (let i = 0; i < pipes.length; i++) {
                const pipe = pipes[i];
                
                // Draw pipe body
                ctx.fillStyle = '#1E90FF'; // Blue color
                ctx.fillRect(pipe.x, 0, pipe.width, pipe.gap.top);
                ctx.fillRect(pipe.x, pipe.gap.bottom, pipe.width, canvas.height - pipe.gap.bottom);
                
                // Draw pipe caps
                ctx.fillStyle = '#4169E1'; // Darker blue for caps
                
                // Top pipe cap
                ctx.fillRect(pipe.x - 10, pipe.gap.top - 20, pipe.width + 20, 20);
                
                // Bottom pipe cap
                ctx.fillRect(pipe.x - 10, pipe.gap.bottom, pipe.width + 20, 20);
                
                // Add highlights
                ctx.fillStyle = '#87CEEB'; // Light blue for highlights
                
                // Top pipe highlight
                ctx.fillRect(pipe.x + 5, 0, 5, pipe.gap.top - 20);
                
                // Bottom pipe highlight
                ctx.fillRect(pipe.x + 5, pipe.gap.bottom + 20, 5, canvas.height - pipe.gap.bottom - 20);
            }
        }

        // Spawn pipe
        function spawnPipe() {
            const pipeWidth = 60; // Reduced from 80px
            const minGapSize = 200; // Increased from 150px
            const maxGapSize = 250;
            
            // Ensure the gap is near the player's position
            const playerY = player.y;
            const minGapTop = Math.max(50, playerY - 100);
            const maxGapTop = Math.min(canvas.height - minGapSize - 50, playerY + 100);
            
            const gapTop = Math.max(minGapTop, Math.min(maxGapTop, 50 + Math.random() * (canvas.height - minGapSize - 100)));
            const gapSize = minGapSize + Math.random() * (maxGapSize - minGapSize);
            const gapBottom = gapTop + gapSize;
            
            pipes.push({
                x: canvas.width,
                width: pipeWidth,
                gap: {
                    top: gapTop,
                    bottom: gapBottom
                }
            });
            
            // Chance to spawn sea turtle or snake with pipe
            if (Math.random() < 0.3) {
                const enemyType = Math.random() < 0.5 ? 'seaTurtle' : 'snake';
                const yPos = gapTop + (gapSize / 2) - 20; // Position in middle of gap
                
                spawnSpecialEnemy(enemyType, yPos);
            }
        }

        // Spawn special enemy (sea turtle or snake)
        function spawnSpecialEnemy(type, yPos) {
            const enemyTypes = {
                'seaTurtle': {
                    width: 50,
                    height: 40,
                    health: 8,
                    fireRate: 0.003,
                    pattern: 'zigzag',
                    color: '#2E8B57', // Sea green
                    projectileType: 'bubble',
                    image: seaTurtleImage
                },
                'snake': {
                    width: 60,
                    height: 30,
                    health: 6,
                    fireRate: 0.007,
                    pattern: 'sine',
                    color: '#9ACD32', // Yellow green
                    projectileType: 'poison',
                    image: snakeImage
                }
            };
            
            const enemyType = enemyTypes[type];
            
            const enemy = {
                x: canvas.width,
                y: yPos,
                baseY: yPos,
                width: enemyType.width,
                height: enemyType.height,
                health: enemyType.health,
                fireRate: enemyType.fireRate,
                pattern: enemyType.pattern,
                color: enemyType.color,
                projectileType: enemyType.projectileType,
                image: enemyType.image,
                id: Date.now() + Math.random() * 1000, // Unique ID
                type: type
            };
            
            enemies.push(enemy);
        }

        // Update enemies
        function updateEnemies() {
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                
                // Apply movement pattern
                switch (enemy.pattern) {
                    case 'sine':
                        enemy.x -= gameSpeed * 1.2;
                        enemy.y = enemy.baseY + Math.sin(enemy.x * 0.02) * 50;
                        break;
                    case 'zigzag':
                        enemy.x -= gameSpeed * 1.1;
                        enemy.zigzagTimer = (enemy.zigzagTimer || 0) + 1;
                        if (enemy.zigzagTimer > 30) {
                            enemy.zigzagDir = !enemy.zigzagDir;
                            enemy.zigzagTimer = 0;
                        }
                        enemy.y += (enemy.zigzagDir ? 2 : -2);
                        break;
                    case 'chase':
                        enemy.x -= gameSpeed * 0.8;
                        if (enemy.y < player.y) {
                            enemy.y += 1;
                        } else {
                            enemy.y -= 1;
                        }
                        break;
                    case 'circular':
                        enemy.circleAngle = (enemy.circleAngle || 0) + 0.02;
                        enemy.x -= gameSpeed * 0.9;
                        enemy.y = enemy.baseY + Math.sin(enemy.circleAngle) * 40;
                        break;
                    default:
                        enemy.x -= gameSpeed;
                }
                
                // Keep enemies within canvas bounds
                if (enemy.y < 0) {
                    enemy.y = 0;
                } else if (enemy.y + enemy.height > canvas.height) {
                    enemy.y = canvas.height - enemy.height;
                }
                
                // Fire projectiles randomly
                if (Math.random() < enemy.fireRate) {
                    fireEnemyProjectile(enemy);
                }
                
                // Remove enemies that are off screen
                if (enemy.x + enemy.width < 0) {
                    enemies.splice(i, 1);
                    i--;
                }
            }
            
            // Spawn new enemies if needed
            if (enemies.length < 3 && Math.random() < 0.01) {
                spawnEnemy();
            }
        }

        // Draw enemies
        function drawEnemies() {
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                
                // Check if this enemy is attacking
                const isAttacking = enemyAttackingStates[enemy.id] && 
                                   enemyAttackingStates[enemy.id].attacking;
                
                if (isAttacking) {
                    animateEnemyWhaleAttack(ctx, enemy, frameCount, true);
                } else {
                    animateEnemyWhaleSwim(ctx, enemy, frameCount);
                }
            }
        }

        // Spawn enemy
        function spawnEnemy() {
            const enemyTypes = [
                {
                    width: 60,
                    height: 40,
                    health: 10,
                    fireRate: 0.005,
                    pattern: 'sine',
                    color: '#FF5252',
                    projectileType: 'normal'
                },
                {
                    width: 70,
                    height: 45,
                    health: 15,
                    fireRate: 0.01,
                    pattern: 'zigzag',
                    color: '#FF9800',
                    projectileType: 'fire'
                },
                {
                    width: 80,
                    height: 50,
                    health: 20,
                    fireRate: 0.015,
                    pattern: 'chase',
                    color: '#2196F3',
                    projectileType: 'ice'
                },
                {
                    width: 65,
                    height: 42,
                    health: 12,
                    fireRate: 0.008,
                    pattern: 'circular',
                    color: '#9C27B0',
                    projectileType: 'electric'
                },
                {
                    width: 75,
                    height: 48,
                    health: 18,
                    fireRate: 0.012,
                    pattern: 'sine',
                    color: '#F44336',
                    projectileType: 'rocket'
                }
            ];
            
            const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
            const imageIndex = Math.floor(Math.random() * enemyImageObjects.length);
            
            const enemy = {
                x: canvas.width,
                y: 50 + Math.random() * (canvas.height - 100),
                baseY: 50 + Math.random() * (canvas.height - 100),
                width: enemyType.width,
                height: enemyType.height,
                health: enemyType.health,
                fireRate: enemyType.fireRate,
                pattern: enemyType.pattern,
                color: enemyType.color,
                projectileType: enemyType.projectileType,
                image: enemyImageObjects[imageIndex],
                id: Date.now() + Math.random() * 1000 // Unique ID
            };
            
            enemies.push(enemy);
        }

        // Update projectiles
        function updateProjectiles() {
            for (let i = 0; i < projectiles.length; i++) {
                // Apply base movement
                projectiles[i].x += projectiles[i].speed;
                
                // Apply vertical movement if specified
                if (projectiles[i].speedY) {
                    projectiles[i].y += projectiles[i].speedY;
                }
                
                // Auto-targeting logic
                if (enemies.length > 0) {
                    // Find the closest enemy
                    let closestEnemy = null;
                    let closestDistance = Infinity;
                    
                    for (let j = 0; j < enemies.length; j++) {
                        const dx = enemies[j].x - projectiles[i].x;
                        const dy = (enemies[j].y + enemies[j].height / 2) - projectiles[i].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestEnemy = enemies[j];
                        }
                    }
                    
                    // If enemy is within range, adjust trajectory
                    if (closestEnemy && closestDistance < 200) {
                        const targetY = closestEnemy.y + closestEnemy.height / 2;
                        const dy = targetY - projectiles[i].y;
                        
                        // Gradually adjust y position towards target
                        projectiles[i].y += dy * 0.05;
                    }
                }
                
                // Remove projectiles that are off screen
                if (projectiles[i].x > canvas.width || 
                    projectiles[i].y < 0 || 
                    projectiles[i].y > canvas.height) {
                    projectiles.splice(i, 1);
                    i--;
                }
            }
        }

        // Draw projectiles
        function drawProjectiles() {
            for (let i = 0; i < projectiles.length; i++) {
                // Set fill style based on projectile color
                ctx.fillStyle = projectiles[i].color || '#FFD700';
                
                // Draw projectile
                ctx.beginPath();
                ctx.arc(projectiles[i].x, projectiles[i].y, projectiles[i].radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glow effect
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.shadowBlur = 10;
                ctx.shadowColor = projectiles[i].color || '#FFD700';
                ctx.beginPath();
                ctx.arc(projectiles[i].x, projectiles[i].y, projectiles[i].radius * 1.5, 0, Math.PI * 2);
                ctx.fill();
                ctx.restore();
            }
        }

        // Fire projectile
        function fireProjectile() {
            // Create main projectile (straight ahead)
            projectiles.push({
                x: player.x + player.width,
                y: player.y + player.height / 2,
                radius: 5,
                speed: 10,
                damage: 10,
                color: '#FFD700'
            });
            
            // Create additional projectiles in different directions
            // Upward projectile
            projectiles.push({
                x: player.x + player.width,
                y: player.y + player.height / 2,
                radius: 4,
                speed: 9,
                speedY: -2, // Move upward
                damage: 8,
                color: '#FFA500'
            });
            
            // Downward projectile
            projectiles.push({
                x: player.x + player.width,
                y: player.y + player.height / 2,
                radius: 4,
                speed: 9,
                speedY: 2, // Move downward
                damage: 8,
                color: '#FFA500'
            });
            
            // Spread projectile (slight upward angle)
            projectiles.push({
                x: player.x + player.width,
                y: player.y + player.height / 2 - 5,
                radius: 3,
                speed: 8,
                speedY: -1, // Slight upward angle
                damage: 6,
                color: '#FFFF00'
            });
            
            // Spread projectile (slight downward angle)
            projectiles.push({
                x: player.x + player.width,
                y: player.y + player.height / 2 + 5,
                radius: 3,
                speed: 8,
                speedY: 1, // Slight downward angle
                damage: 6,
                color: '#FFFF00'
            });
            
            // Trigger attack animation
            triggerMainWhaleAttack();
        }

        // Update enemy projectiles
        function updateEnemyProjectiles() {
            for (let i = 0; i < enemyProjectiles.length; i++) {
                const projectile = enemyProjectiles[i];
                
                // Apply base movement
                projectile.x -= projectile.baseSpeed;
                
                // Apply additional movement vectors
                if (projectile.speedX) {
                    projectile.x -= projectile.speedX;
                }
                
                if (projectile.speedY) {
                    projectile.y += projectile.speedY;
                }
                
                // Apply special effects
                if (projectile.accelerate) {
                    projectile.baseSpeed *= 1.02; // Accelerate over time
                }
                
                if (projectile.pulsate) {
                    projectile.pulsePhase = (projectile.pulsePhase || 0) + 0.1;
                    projectile.radius = 5 + Math.sin(projectile.pulsePhase) * 2;
                }
                
                if (projectile.particles && Math.random() < 0.3) {
                    // Create trailing particles
                    createParticle(projectile.x, projectile.y, projectile.color, 0.7);
                }
                
                if (projectile.trail && Math.random() < 0.2) {
                    // Create trail effect
                    createTrail(projectile.x, projectile.y, projectile.color);
                }
                
                if (projectile.smoke && Math.random() < 0.2) {
                    // Create smoke effect
                    createSmoke(projectile.x, projectile.y);
                }
                
                // Remove projectiles that are off screen
                if (projectile.x < 0 || projectile.y < 0 || projectile.y > canvas.height) {
                    enemyProjectiles.splice(i, 1);
                    i--;
                }
            }
        }

        // Draw enemy projectiles
        function drawEnemyProjectiles() {
            for (let i = 0; i < enemyProjectiles.length; i++) {
                const projectile = enemyProjectiles[i];
                
                // Set fill style based on projectile color
                ctx.fillStyle = projectile.color || '#FF5252';
                
                // Draw projectile
                ctx.beginPath();
                ctx.arc(projectile.x, projectile.y, projectile.radius, 0, Math.PI * 2);
                ctx.fill();
                
                // Add glow effect for special projectiles
                if (projectile.type !== 'normal') {
                    ctx.save();
                    ctx.globalAlpha = 0.5;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = projectile.color;
                    ctx.beginPath();
                    ctx.arc(projectile.x, projectile.y, projectile.radius * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }
            }
        }

        // Create particle effect
        function createParticle(x, y, color, alpha) {
            particles.push({
                x: x,
                y: y,
                radius: Math.random() * 3 + 1,
                velocityX: (Math.random() - 0.5) * 2,
                velocityY: (Math.random() - 0.5) * 2,
                alpha: alpha || 1,
                color: color || '#FFD700'
            });
        }

        // Create trail effect
        function createTrail(x, y, color) {
            for (let i = 0; i < 3; i++) {
                particles.push({
                    x: x,
                    y: y,
                    radius: 2,
                    velocityX: 0,
                    velocityY: 0,
                    alpha: 0.7,
                    color: color,
                    fadeSpeed: 0.02
                });
            }
        }

        // Create smoke effect
        function createSmoke(x, y) {
            for (let i = 0; i < 2; i++) {
                particles.push({
                    x: x + (Math.random() - 0.5) * 5,
                    y: y + (Math.random() - 0.5) * 5,
                    radius: Math.random() * 5 + 3,
                    velocityX: 1,
                    velocityY: (Math.random() - 0.5) * 0.5,
                    alpha: 0.5,
                    color: '#888888',
                    fadeSpeed: 0.01,
                    growSpeed: 0.1
                });
            }
        }

        // Fire enemy projectile
        function fireEnemyProjectile(enemy) {
            // Create projectile with custom properties based on enemy type
            const projectileTypes = {
                'normal': {
                    radius: 5,
                    baseSpeed: 5,
                    color: '#FF5252',
                    damage: 10
                },
                'fire': {
                    radius: 6,
                    baseSpeed: 6,
                    color: '#FF9800',
                    damage: 15,
                    particles: true,
                    trail: true
                },
                'ice': {
                    radius: 4,
                    baseSpeed: 7,
                    color: '#2196F3',
                    damage: 12,
                    pulsate: true
                },
                'electric': {
                    radius: 5,
                    baseSpeed: 8,
                    color: '#9C27B0',
                    damage: 18,
                    zigzag: true
                },
                'rocket': {
                    radius: 7,
                    baseSpeed: 4,
                    color: '#F44336',
                    damage: 20,
                    accelerate: true,
                    smoke: true
                },
                'bubble': {
                    radius: 6,
                    baseSpeed: 4,
                    color: '#00CED1', // Turquoise
                    damage: 8,
                    pulsate: true
                },
                'poison': {
                    radius: 4,
                    baseSpeed: 6,
                    color: '#7CFC00', // Lawn green
                    damage: 14,
                    trail: true
                }
            };
            
            const projectileType = projectileTypes[enemy.projectileType] || projectileTypes.normal;
            
            // Determine attack pattern
            const attackPatterns = ['single', 'double', 'triple', 'spread', 'aimed'];
            const pattern = attackPatterns[Math.floor(Math.random() * attackPatterns.length)];
            
            // Create projectiles based on pattern
            switch (pattern) {
                case 'single':
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height / 2,
                        ...projectileType,
                        type: enemy.projectileType
                    });
                    break;
                case 'double':
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height / 4,
                        ...projectileType,
                        type: enemy.projectileType
                    });
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height * 3/4,
                        ...projectileType,
                        type: enemy.projectileType
                    });
                    break;
                case 'triple':
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height / 2,
                        ...projectileType,
                        type: enemy.projectileType
                    });
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height / 4,
                        ...projectileType,
                        type: enemy.projectileType
                    });
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height * 3/4,
                        ...projectileType,
                        type: enemy.projectileType
                    });
                    break;
                case 'spread':
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height / 2,
                        ...projectileType,
                        type: enemy.projectileType
                    });
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height / 2,
                        ...projectileType,
                        speedY: 2,
                        type: enemy.projectileType
                    });
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height / 2,
                        ...projectileType,
                        speedY: -2,
                        type: enemy.projectileType
                    });
                    break;
                case 'aimed':
                    const dx = player.x - enemy.x;
                    const dy = player.y - enemy.y;
                    const angle = Math.atan2(dy, -dx);
                    
                    enemyProjectiles.push({
                        x: enemy.x,
                        y: enemy.y + enemy.height / 2,
                        ...projectileType,
                        baseSpeed: projectileType.baseSpeed * 0.7,
                        speedY: Math.sin(angle) * projectileType.baseSpeed,
                        type: enemy.projectileType
                    });
                    break;
            }
            
            // Trigger enemy attack animation
            triggerEnemyWhaleAttack(enemy.id);
        }

        // Update particles
        function updateParticles() {
            for (let i = 0; i < particles.length; i++) {
                particles[i].x += particles[i].velocityX;
                particles[i].y += particles[i].velocityY;
                
                // Apply fade effect
                if (particles[i].fadeSpeed) {
                    particles[i].alpha -= particles[i].fadeSpeed;
                } else {
                    particles[i].alpha -= 0.01;
                }
                
                // Apply grow effect
                if (particles[i].growSpeed) {
                    particles[i].radius += particles[i].growSpeed;
                }
                
                // Remove particles that are faded out
                if (particles[i].alpha <= 0) {
                    particles.splice(i, 1);
                    i--;
                }
            }
        }

        // Draw particles
        function drawParticles() {
            for (let i = 0; i < particles.length; i++) {
                ctx.save();
                ctx.globalAlpha = particles[i].alpha;
                ctx.fillStyle = particles[i].color;
                
                ctx.beginPath();
                ctx.arc(particles[i].x, particles[i].y, particles[i].radius, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        // Create explosion effect
        function createExplosion(x, y, color) {
            for (let i = 0; i < 20; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 3 + 1;
                
                particles.push({
                    x: x,
                    y: y,
                    radius: Math.random() * 5 + 2,
                    velocityX: Math.cos(angle) * speed,
                    velocityY: Math.sin(angle) * speed,
                    alpha: 1,
                    color: color || '#FFD700',
                    fadeSpeed: 0.02
                });
            }
        }

        // Update power-ups
        function updatePowerUps() {
            for (let i = 0; i < powerUps.length; i++) {
                powerUps[i].x -= gameSpeed;
                
                // Apply floating effect
                powerUps[i].floatOffset = Math.sin(frameCount * 0.05) * 5;
                
                // Remove power-ups that are off screen
                if (powerUps[i].x + powerUps[i].width < 0) {
                    powerUps.splice(i, 1);
                    i--;
                }
            }
        }

        // Draw power-ups
        function drawPowerUps() {
            for (let i = 0; i < powerUps.length; i++) {
                const powerUp = powerUps[i];
                
                // Draw power-up
                ctx.fillStyle = powerUp.color;
                ctx.beginPath();
                ctx.arc(
                    powerUp.x + powerUp.width / 2, 
                    powerUp.y + powerUp.height / 2 + powerUp.floatOffset, 
                    powerUp.width / 2, 
                    0, 
                    Math.PI * 2
                );
                ctx.fill();
                
                // Draw glow effect
                ctx.save();
                ctx.globalAlpha = 0.5;
                ctx.shadowBlur = 15;
                ctx.shadowColor = powerUp.color;
                ctx.beginPath();
                ctx.arc(
                    powerUp.x + powerUp.width / 2, 
                    powerUp.y + powerUp.height / 2 + powerUp.floatOffset, 
                    powerUp.width / 2 * 1.2, 
                    0, 
                    Math.PI * 2
                );
                ctx.fill();
                ctx.restore();
                
                // Draw icon
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(
                    powerUp.icon, 
                    powerUp.x + powerUp.width / 2, 
                    powerUp.y + powerUp.height / 2 + powerUp.floatOffset
                );
            }
        }

        // Spawn power-up
        function spawnPowerUp() {
            const powerUpTypes = [
                {
                    type: 'health',
                    color: '#4CAF50',
                    icon: '+'
                },
                {
                    type: 'power',
                    color: '#2196F3',
                    icon: 'P'
                },
                {
                    type: 'speed',
                    color: '#FFC107',
                    icon: 'S'
                },
                {
                    type: 'shield',
                    color: '#9C27B0',
                    icon: 'O'
                }
            ];
            
            const powerUpType = powerUpTypes[Math.floor(Math.random() * powerUpTypes.length)];
            
            powerUps.push({
                x: canvas.width,
                y: 50 + Math.random() * (canvas.height - 100),
                width: 30,
                height: 30,
                floatOffset: 0,
                ...powerUpType
            });
            
            // Schedule next power-up
            setTimeout(spawnPowerUp, 10000 + Math.random() * 10000);
        }

        // Check collisions
        function checkCollisions() {
            // Player-pipe collisions
            for (let i = 0; i < pipes.length; i++) {
                if (
                    player.x < pipes[i].x + pipes[i].width &&
                    player.x + player.width > pipes[i].x &&
                    (
                        player.y < pipes[i].gap.top ||
                        player.y + player.height > pipes[i].gap.bottom
                    )
                ) {
                    // Push player back slightly and take minor damage instead of ending game
                    player.x -= 10;
                    takeDamage(5);
                    
                    // Create impact particles
                    for (let j = 0; j < 5; j++) {
                        createParticle(player.x + player.width, player.y + player.height / 2, '#FFFFFF');
                    }
                }
            }
            
            // Player-enemy collisions
            for (let i = 0; i < enemies.length; i++) {
                if (
                    player.x < enemies[i].x + enemies[i].width &&
                    player.x + player.width > enemies[i].x &&
                    player.y < enemies[i].y + enemies[i].height &&
                    player.y + player.height > enemies[i].y
                ) {
                    // Take damage
                    takeDamage(20);
                    
                    // Create explosion
                    createExplosion(enemies[i].x, enemies[i].y, enemies[i].color);
                    
                    // Remove enemy
                    enemies.splice(i, 1);
                    i--;
                }
            }
            
            // Player-enemy projectile collisions
            for (let i = 0; i < enemyProjectiles.length; i++) {
                const dx = player.x + player.width / 2 - enemyProjectiles[i].x;
                const dy = player.y + player.height / 2 - enemyProjectiles[i].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance < player.width / 2 + enemyProjectiles[i].radius) {
                    // Take damage
                    takeDamage(enemyProjectiles[i].damage);
                    
                    // Create impact particles
                    for (let j = 0; j < 5; j++) {
                        createParticle(
                            enemyProjectiles[i].x, 
                            enemyProjectiles[i].y, 
                            enemyProjectiles[i].color
                        );
                    }
                    
                    // Remove projectile
                    enemyProjectiles.splice(i, 1);
                    i--;
                }
            }
            
            // Projectile-enemy collisions
            for (let i = 0; i < projectiles.length; i++) {
                for (let j = 0; j < enemies.length; j++) {
                    if (
                        projectiles[i].x > enemies[j].x &&
                        projectiles[i].x < enemies[j].x + enemies[j].width &&
                        projectiles[i].y > enemies[j].y &&
                        projectiles[i].y < enemies[j].y + enemies[j].height
                    ) {
                        // Damage enemy
                        enemies[j].health -= projectiles[i].damage;
                        
                        // Create impact particles
                        for (let k = 0; k < 5; k++) {
                            createParticle(
                                projectiles[i].x, 
                                projectiles[i].y, 
                                projectiles[i].color
                            );
                        }
                        
                        // Remove projectile
                        projectiles.splice(i, 1);
                        i--;
                        
                        // Check if enemy is defeated
                        if (enemies[j].health <= 0) {
                            // Create explosion
                            createExplosion(enemies[j].x, enemies[j].y, enemies[j].color);
                            
                            // Increase score
                            score += 50;
                            scoreDisplay.textContent = Math.floor(score);
                            
                            // Increase power
                            power += 10;
                            updatePowerBar();
                            
                            // Increase combo
                            combo++;
                            updateComboDisplay();
                            
                            // Remove enemy
                            enemies.splice(j, 1);
                            j--;
                        }
                        
                        break;
                    }
                }
            }
            
            // Player-power-up collisions
            for (let i = 0; i < powerUps.length; i++) {
                if (
                    player.x < powerUps[i].x + powerUps[i].width &&
                    player.x + player.width > powerUps[i].x &&
                    player.y < powerUps[i].y + powerUps[i].height &&
                    player.y + player.height > powerUps[i].y
                ) {
                    // Apply power-up effect
                    applyPowerUp(powerUps[i]);
                    
                    // Create collection particles
                    for (let j = 0; j < 10; j++) {
                        createParticle(
                            powerUps[i].x + powerUps[i].width / 2, 
                            powerUps[i].y + powerUps[i].height / 2, 
                            powerUps[i].color
                        );
                    }
                    
                    // Remove power-up
                    powerUps.splice(i, 1);
                    i--;
                }
            }
        }

        // Take damage
        function takeDamage(amount) {
            health -= amount;
            
            // Update health bar
            updateHealthBar();
            
            // Reset combo
            combo = 0;
            comboDisplay.style.opacity = '0';
            
            // Check if game over
            if (health <= 0) {
                gameOver();
            }
        }

        // Update health bar
        function updateHealthBar() {
            healthBar.style.width = `${Math.max(0, health)}%`;
        }

        // Update power bar
        function updatePowerBar() {
            power = Math.min(100, power);
            powerBar.style.width = `${power}%`;
        }

        // Update combo display
        function updateComboDisplay() {
            comboDisplay.textContent = `Combo x${combo}`;
            comboDisplay.style.opacity = '1';
            
            // Hide combo display after a delay
            setTimeout(() => {
                comboDisplay.style.opacity = '0';
            }, 2000);
        }

        // Apply power-up
        function applyPowerUp(powerUp) {
            switch (powerUp.type) {
                case 'health':
                    health = Math.min(100, health + 20);
                    updateHealthBar();
                    showPowerUpNotification('Health +20');
                    break;
                case 'power':
                    power = Math.min(100, power + 30);
                    updatePowerBar();
                    showPowerUpNotification('Power +30');
                    break;
                case 'speed':
                    player.fireRate = Math.max(15, player.fireRate - 5);
                    showPowerUpNotification('Fire Rate Increased');
                    break;
                case 'shield':
                    // Add shield effect (to be implemented)
                    showPowerUpNotification('Shield Activated');
                    break;
            }
        }

        // Show power-up notification
        function showPowerUpNotification(text) {
            powerUpNotification.textContent = text;
            powerUpNotification.style.opacity = '1';
            
            // Hide notification after a delay
            setTimeout(() => {
                powerUpNotification.style.opacity = '0';
            }, 2000);
        }

        // Use special attack
        function useSpecialAttack() {
            if (power >= 50) {
                // Reduce power
                power -= 50;
                updatePowerBar();
                
                // Clear all enemies and enemy projectiles
                for (let i = 0; i < enemies.length; i++) {
                    createExplosion(enemies[i].x, enemies[i].y, '#4169E1');
                }
                
                enemies = [];
                enemyProjectiles = [];
                
                // Create special attack effect
                for (let i = 0; i < 50; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const distance = Math.random() * 100 + 50;
                    const x = player.x + Math.cos(angle) * distance;
                    const y = player.y + Math.sin(angle) * distance;
                    
                    createParticle(x, y, '#4169E1');
                }
                
                // Increase score
                score += 50;
                scoreDisplay.textContent = Math.floor(score);
            }
        }

        // Draw background
        function drawBackground() {
            // Draw background gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, '#4169E1');
            gradient.addColorStop(1, '#000080');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw clouds at top
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            for (let i = 0; i < 5; i++) {
                const x = (i * canvas.width / 5 + frameCount * 0.2) % canvas.width;
                const y = 30;
                const size = 30 + Math.sin(frameCount * 0.01 + i) * 5;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(x + 20, y - 10, size * 0.7, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.beginPath();
                ctx.arc(x - 20, y - 5, size * 0.6, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw water at bottom with white foam
            // First draw the base water layer
            const waterGradient = ctx.createLinearGradient(0, canvas.height - 40, 0, canvas.height);
            waterGradient.addColorStop(0, 'rgba(0, 191, 255, 0.5)');
            waterGradient.addColorStop(1, 'rgba(0, 105, 148, 0.7)');
            
            ctx.fillStyle = waterGradient;
            
            // Draw animated waves base
            const waveHeight = 20;
            const waveCount = 5;
            const waveFrequency = 0.05;
            const waveSpeed = 0.1;
            
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            
            for (let x = 0; x <= canvas.width; x += 10) {
                const y = canvas.height - waveHeight - Math.sin((x * waveFrequency) + (frameCount * waveSpeed)) * waveHeight;
                ctx.lineTo(x, y);
            }
            
            ctx.lineTo(canvas.width, canvas.height);
            ctx.closePath();
            ctx.fill();
            
            // Now draw the white foam on top of the waves
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            
            // Draw foam at the top of the waves
            ctx.beginPath();
            ctx.moveTo(0, canvas.height);
            
            for (let x = 0; x <= canvas.width; x += 5) {
                const baseY = canvas.height - waveHeight - Math.sin((x * waveFrequency) + (frameCount * waveSpeed)) * waveHeight;
                const foamHeight = 5 + Math.random() * 3;
                ctx.lineTo(x, baseY - foamHeight);
            }
            
            // Connect back to the wave line
            for (let x = canvas.width; x >= 0; x -= 5) {
                const baseY = canvas.height - waveHeight - Math.sin((x * waveFrequency) + (frameCount * waveSpeed)) * waveHeight;
                ctx.lineTo(x, baseY);
            }
            
            ctx.closePath();
            ctx.fill();
            
            // Add some bubble particles in the water
            ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            for (let i = 0; i < 10; i++) {
                const x = (Math.random() * canvas.width + frameCount) % canvas.width;
                const y = canvas.height - Math.random() * 30;
                const size = 1 + Math.random() * 3;
                
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Game over
        function gameOver() {
            gameActive = false;
            
            // Show game over overlay
            finalScoreDisplay.textContent = Math.floor(score);
            gameOverOverlay.classList.add('active');
        }

        // Resize canvas
        function resizeCanvas() {
            canvas.width = gameContainer.clientWidth;
            canvas.height = gameContainer.clientHeight;
            
            // Update player position
            player.x = canvas.width / 4; // Fixed horizontal position in left side
        }

        // Toggle orientation
        function toggleOrientation() {
            isVertical = !isVertical;
            
            if (isVertical) {
                document.body.classList.add('vertical');
            } else {
                document.body.classList.remove('vertical');
            }
            
            // Resize canvas after orientation change
            setTimeout(resizeCanvas, 300);
        }

        // Event listeners
        window.addEventListener('load', () => {
            console.log("Window loaded!");
            // Set initial canvas size
            resizeCanvas();
            
            // Start button
            startButton.addEventListener('click', () => {
                console.log("Start button clicked!");
                startOverlay.classList.remove('active');
                initGame();
            });
            
            // Restart button
            restartButton.addEventListener('click', () => {
                gameOverOverlay.classList.remove('active');
                initGame();
            });
            
            // Keyboard controls
            window.addEventListener('keydown', (e) => {
                if (!gameActive) return;
                
                switch (e.key) {
                    case ' ':
                    case 'ArrowUp':
                        // Jump
                        player.velocity = -8;
                        player.isJumping = true;
                        break;
                    case 'ArrowDown':
                        // Fast fall
                        player.velocity = 8;
                        break;
                    case 'f':
                    case 'F':
                        // Fire projectile
                        fireProjectile();
                        break;
                    case 's':
                    case 'S':
                        // Special attack
                        useSpecialAttack();
                        break;
                }
            });
            
            // Mobile controls
            document.getElementById('mobile-up').addEventListener('touchstart', () => {
                if (!gameActive) return;
                player.velocity = -8;
                player.isJumping = true;
            });
            
            document.getElementById('mobile-down').addEventListener('touchstart', () => {
                if (!gameActive) return;
                player.velocity = 8;
            });
            
            document.getElementById('combat-fire').addEventListener('touchstart', () => {
                if (!gameActive) return;
                fireProjectile();
            });
            
            document.getElementById('combat-special').addEventListener('touchstart', () => {
                if (!gameActive) return;
                useSpecialAttack();
            });
            
            // Orientation toggle
            orientationToggle.addEventListener('click', toggleOrientation);
            
            // Window resize
            window.addEventListener('resize', resizeCanvas);
            
            // Spawn power-ups
            setTimeout(spawnPowerUp, 10000);
        });

        // Add console debugging
        console.log("Script loaded successfully!");
    </script>
</body>
</html>
